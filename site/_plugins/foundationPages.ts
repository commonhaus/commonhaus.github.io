import Site from "lume/core/site.ts";
import modifyUrls from "lume/plugins/modify_urls.ts";
import { parse } from "@std/yaml";
import { Data, Page } from "lume/core/file.ts";
import { dirname } from "@std/path/dirname";
import { join, normalize } from "https://deno.land/std@0.203.0/path/mod.ts";

interface LogoDisplay {
    logo?: string;
    "logo-dark"?: string;
}
interface Project {
    name: string;
    repo: string;
    display?: LogoDisplay;
    draft?: boolean;
}
interface SponsorData {
    sponsors: Record<string, Sponsor>;
}
interface Sponsor {
    display?: LogoDisplay;
    inKind?: LogoDisplay;
}

// -------------------
// Foundation Data: submodule pages
// - foundation.json is generated by ./.github/lastmod.ts
// - foundation.yml  is manually maintained: descriptions, resulting page url, etc.
const FOUNDATION_PAGES = parse(Deno.readTextFileSync("./site/_foundation.yml")) as Record<string, Data>;
const PROJECT_DATA: Record<string, Project> = parse(Deno.readTextFileSync("./foundation-content/PROJECTS.yaml")) as Record<string, Project>;
const SPONSOR_DATA: SponsorData = parse(Deno.readTextFileSync("./foundation-content/SPONSORS.yaml")) as SponsorData;

const IMPORTED_LOGO_URLS: Record<string, string> = {};

const rawUrl = (url: string) => {
    if (url.includes("/github.com/") && !url.endsWith("?raw=true")) {
        url += "?raw=true";
    }
    return url;
}

const unrawUrl = (url: string) => {
    return url.replace("?raw=true", "");
}

const fixFoundationUrls = (url: string, page: Page) => {
    const cachedLocalImg = IMPORTED_LOGO_URLS[unrawUrl(url)];
    if (cachedLocalImg) {
        // Fix sponsor and project logo URLs to reference local images
        return cachedLocalImg;
    }
    if (url.startsWith('http') || url.startsWith('#')) {
        return url;
    }
    const match = url.match(/([^#]*\.md)(#.*)?/);
    if (match) {
        let resolvedPath;
        if (match[1].startsWith('/foundation')) {
            resolvedPath = match[1].replace(/\/foundation(-content)?\//, '');
        } else {
            let dir = page.data.srcPath || page.src.path;
            if (dir.endsWith('.md')) {
                dir = dirname(dir);
            }
            resolvedPath = normalize(join(dir, match[1]));
        }
        const target = FOUNDATION_PAGES[resolvedPath.replace('.md', '')];
        return target.url + (match[2] || '');
    }

    // Replace references to CONTACTS.yaml with the URL from the foundation repo
    if (url.includes('CONTACTS.yaml')) {
        return 'https://github.com/commonhaus/foundation/blob/main/CONTACTS.yaml';
    }
    // Replace references to project templates with the URL from the foundation repo
    if (url.includes('../../templates')) {
        return url.replace('../../templates', 'https://github.com/commonhaus/foundation/blob/main/templates');
    }
    // remaining links to CONTRIBUTING.md (from foundation materials) should point to the foundation repo
    if (url.includes('CONTRIBUTING.md')) {
        return 'https://github.com/commonhaus/foundation/blob/main/CONTRIBUTING.md';
    }
    // remaining links to CONTRIBUTING.md (from foundation materials) should point to the foundation repo
    if (url.includes('CODE_OF_CONDUCT.md')) {
        return 'https://github.com/commonhaus/foundation/blob/main/CODE_OF_CONDUCT.md';
    }
    return url;
};

const urlBaseName = (url: string) => {
    return new URL(url).pathname.split('/').pop();
}

const importLogo = (name: string, url: string | undefined, segment: string, site: Site) => {
    if (url && url.startsWith("http")) {
        if (url.startsWith("https://www.commonhaus.org")) {
            IMPORTED_LOGO_URLS[url] = url.replace("https://www.commonhaus.org", "");
            return;
        }
        url = rawUrl(url);
        const baseName = urlBaseName(url);
        if (!baseName) {
            return;
        }
        const file = baseName.startsWith(name)
            ? baseName
            : `${name}-${baseName}`;
        const target = `/images/${segment}/${file}`.replace(/%20/, '-');
        console.log("🏛️ 🖼️ Importing logo", file);
        site.remoteFile(file, url);
        site.copy(file, target);
        IMPORTED_LOGO_URLS[unrawUrl(url)] = target;
    }
}

/**
 * The foundationPages plugin is used to add pages into the index for
 * content in the foundation submodule.
 *
 * Not all content in the foundation submodule is relevant to the commonhaus.org site.
 *
 * The `lastmod` task creates site/_generated/foundation.json, which provides a baseline
 * definition for each file based on git history.
 *
 * This plugin will create a page for each file in site/_foundation.yml. It will augment
 * the data from the foundation.json with manually entered descriptions and specific URLs.
 */
export default function () {
    return (site: Site) => {
        console.log("🏛️ Initializing Foundation Pages plugin");

        // Copy sponsor and project logos to the local site
        for (const [k, v] of Object.entries(SPONSOR_DATA.sponsors)) {
            if (v.display) {
                importLogo(k, v.display.logo, "sponsors", site);
                importLogo(k, v.display["logo-dark"], "sponsors", site);
            }
            if (v.inKind) {
                importLogo(k, v.inKind.logo, "sponsors", site);
                importLogo(k, v.inKind["logo-dark"], "sponsors", site);
            }
        }
        for (const [k, v] of Object.entries(PROJECT_DATA)) {
            if (v.display) {
                importLogo(k, v.display.logo, "projects", site);
                importLogo(k, v.display["logo-dark"], "projects", site);
            }
        }

        site.use(modifyUrls({
            fn: fixFoundationUrls
        }));

        site.preprocess([".html"], (filteredPages) => {
            for (const page of filteredPages) {
                if (page.data.date && page.data.updated) {
                    // For OTHER pages (actions, vote results),
                    // set a boolean value if the updated date is different from the published date
                    page.data.hasUpdate = page.data.date.toDateString() !== page.data.updated.toDateString();
                }
            }
        });

        // Fixup attributes at build time if necessary
        site.preprocess(['.md'], (pages) => {
            console.log("🏛️ Preprocess (md)");

            for (const page of pages) {
                if (typeof page.data.content !== "string") {
                    continue;
                }

                // add function to get list of projects
                page.data.listProjects = () => {
                    return Object.values(PROJECT_DATA)
                        .filter((project) => !project.draft)
                        .map((project) => ({
                            ...project,
                            ...project.display
                        }));
                }
                page.data.archiveByYear = () => {
                    if (!page.data.indexQuery) {
                        return [];
                    }
                    // Group posts matching the given query by year
                    const allPosts = site.search.pages(page.data.indexQuery, "number=desc");
                    const postsByYear: Record<string, Data[]> = {};
                    if (allPosts.length > 0) {
                        allPosts.forEach((post) => {
                            const year = new Date(post.date).getFullYear();
                            if (!postsByYear[year]) {
                                postsByYear[year] = [];
                            }
                            postsByYear[year].push(post);
                        });
                    }
                    return {
                        years: Object.keys(postsByYear).sort((a, b) => Number(b) - Number(a)),
                        posts: postsByYear
                    };
                }
                page.data.indexBySection = () => {
                    const allPosts = site.search.pages("", "url");
                    const postsBySection: Record<string, Data[]> = {};
                    if (allPosts.length > 0) {
                        allPosts.forEach((post) => {
                            if (post.index === false) {
                                return;
                            }
                            const section = post.url.substring(1, post.url.indexOf('/', 1));
                            if (!postsBySection[section]) {
                                postsBySection[section] = [];
                            }
                            postsBySection[section].push(post);
                        });
                    }

                    return {
                        list: Object.keys(postsBySection).sort(),
                        posts: postsBySection
                    };
                }
            }
        });
    };
}